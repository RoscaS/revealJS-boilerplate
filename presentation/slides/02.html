<h2 class="left">Du code</h2>

<section data-transition="slide-in none-out">
  <pre>
    <code lang="cpp" data-trim data-noescape data-line-numbers>
    Person* dumb = new Person("Dumb");
    unique_ptr&lt;Person&gt; smart(new Person("Smart"));
    unique_ptr&lt;int&gt; intPtr(new int[10000000]);

    cout << smart.get() << endl;

    template&lt;class T&gt;
    class Babysitter {
       T *ptr;
    public:
       Babysitter(T *ptr = nullptr) : ptr(ptr) {}
       ~Babysitter() { delete ptr; }

       Babysitter(Babysitter& other) {
           ptr = other.ptr;
           other.ptr = nullptr;
       }

       Babysitter& operator=(Babysitter& other) {
           if (&other == this) return *this;
           delete ptr;
           ptr = other.ptr;
           other.ptr = nullptr;
           return *this;
       }

       bool isNull() const { return ptr == nullptr; }
       T &operator*() const { return *ptr; }
       T *operator->() const { return ptr; }
    };
    </code>
  </pre>
  <small>Overview du code</small>
</section>

<section data-transition="none">
  <pre>
    <code lang="cpp" data-trim data-noescape data-line-numbers="1,2,3">
    Person* dumb = new Person("Dumb");
    unique_ptr&lt;Person&gt; smart(new Person("Smart"));
    unique_ptr&lt;int&gt; intPtr(new int[10000000]);

    cout << smart.get() << endl;

    template&lt;class T&gt;
    class Babysitter {
       T *ptr;
    public:
       Babysitter(T *ptr = nullptr) : ptr(ptr) {}
       ~Babysitter() { delete ptr; }

       Babysitter(Babysitter& other) {
           ptr = other.ptr;
           other.ptr = nullptr;
       }

       Babysitter& operator=(Babysitter& other) {
           if (&other == this) return *this;
           delete ptr;
           ptr = other.ptr;
           other.ptr = nullptr;
           return *this;
       }

       bool isNull() const { return ptr == nullptr; }
       T &operator*() const { return *ptr; }
       T *operator->() const { return ptr; }
    };
    </code>
  </pre>

  <small>Instanciation</small>
</section>

<section data-transition="none">
  <pre>
    <code lang="cpp" data-trim data-noescape data-line-numbers="14,15,16,17">
    Person* dumb = new Person("Dumb");
    unique_ptr&lt;Person&gt; smart(new Person("Smart"));
    unique_ptr&lt;int&gt; intPtr(new int[10000000]);

    cout << smart.get() << endl;

    template&lt;class T&gt;
    class Babysitter {
       T *ptr;
    public:
       Babysitter(T *ptr = nullptr) : ptr(ptr) {}
       ~Babysitter() { delete ptr; }

       Babysitter(Babysitter& other) {
           ptr = other.ptr;
           other.ptr = nullptr;
       }

       Babysitter& operator=(Babysitter& other) {
           if (&other == this) return *this;
           delete ptr;
           ptr = other.ptr;
           other.ptr = nullptr;
           return *this;
       }

       bool isNull() const { return ptr == nullptr; }
       T &operator*() const { return *ptr; }
       T *operator->() const { return ptr; }
    };
    </code>
  </pre>
  <small>Constructeur de copies qui implémente la sémentique de déplacement</small>
</section>

<section data-transition="none">
  <pre>
    <code lang="cpp" data-trim data-noescape data-line-numbers="19,20,21,22,23,24,25">
    Person* dumb = new Person("Dumb");
    unique_ptr&lt;Person&gt; smart(new Person("Smart"));
    unique_ptr&lt;int&gt; intPtr(new int[10000000]);

    cout << smart.get() << endl;

    template&lt;class T&gt;
    class Babysitter {
       T *ptr;
    public:
       Babysitter(T *ptr = nullptr) : ptr(ptr) {}
       ~Babysitter() { delete ptr; }

       Babysitter(Babysitter& other) {
           ptr = other.ptr;
           other.ptr = nullptr;
       }

       Babysitter& operator=(Babysitter& other) {
           if (&other == this) return *this;
           delete ptr;
           ptr = other.ptr;
           other.ptr = nullptr;
           return *this;
       }

       bool isNull() const { return ptr == nullptr; }
       T &operator*() const { return *ptr; }
       T *operator->() const { return ptr; }
    };
    </code>
  </pre>
  <small>Surcharge de l'oppérateur d'initialisation qui implémente la sémentique de déplacement</small>
</section>

